function fieldtripHeadSurface = import_obj(filename, type)

%IMPORTFILE Import data from a text file
%  OBJTBL = IMPORTFILE(FILENAME) reads data from text file FILENAME for
%  the default selection.  Returns the data as a table.
%
%  OBJTBL = IMPORTFILE(FILE, DATALINES) reads data for the specified row
%  interval(s) of text file FILENAME. Specify DATALINES as a positive
%  scalar integer or a N-by-2 array of positive scalar integers for
%  dis-contiguous row intervals.
%
%  Example:
%  objtbl = importfile("F:\yash\ADRD\20220330103800_1.obj", [3, Inf]);
%
%  See also READTABLE.
%
% Auto-generated by MATLAB on 05-Apr-2022 15:58:17

%% Set up the Import Options and import the data

% Specify range and delimiter
if type=="meshed"
    opts = delimitedTextImportOptions("NumVariables", 10);
    opts.Delimiter = [" ", "/"];
    opts.VariableNames = ["type", "c1", "c2", "c3", "c4", "c5", "c6","c7","c8","c9"];
    opts.VariableTypes = ["categorical", "double", "double", "double", "double", "double", "double","double", "double", "double"]; 
else
    opts = delimitedTextImportOptions("NumVariables", 7);
    opts.Delimiter = [" ", "//"];
    opts.VariableNames = ["type", "c1", "c2", "c3", "c4", "c5", "c6"];
    opts.VariableTypes = ["categorical", "double", "double", "double", "double", "double", "double"];
end
opts.DataLines = [1,Inf];
% Specify file level properties
opts.ExtraColumnsRule = "ignore";
opts.EmptyLineRule = "read";

% Specify variable properties
opts = setvaropts(opts, "type", "EmptyFieldRule", "auto");

% Import the data
objtbl = readtable(filename, opts);

obj = struct;
obj.Vertices = objtbl{objtbl.type == "v",2:4};
obj.VertexNormals = objtbl{objtbl.type == "vn",2:4};
if type=="meshed"
    obj.Faces = objtbl{objtbl.type == "f",[2,5,8]};
    obj.TextCoords = objtbl{objtbl.type == "vt",2:3};
    obj.TextIndices = objtbl{objtbl.type == "f",[3,6,9]};
else
    obj.FaceVertexCData = objtbl{objtbl.type == "v",5:7};
    obj.Faces = objtbl{objtbl.type == "f",[2,4,6]};
end

%% Refine triangles and mesh. Generate color matrix.

pos = obj.Vertices;
tri = obj.Faces;
texture = obj.TextCoords;
textureIdx = obj.TextIndices;

% Check if there exists a .jpg file of 'filename'
[pathstr, name] = fileparts(filename);
if exist(fullfile(pathstr, [name, '.jpg']), 'file')
    image = fullfile(pathstr, [name, '.jpg']);
    hasimage = true;
elseif exist(fullfile(pathstr,[name,'.png']), 'file')
    image    = fullfile(pathstr,[name,'.png']);
    hasimage = true;
 else
    hasimage = false;
end

% Check if the texture is defined per vertex, in which case the texture can
% be refined below
if size(texture, 1)==size(pos, 1)
      texture_per_vert = true;
else
      texture_per_vert = false;
end

% Remove the triangles with 0's first
allzeros = sum(tri==0,2)==3;
tri(allzeros, :)        = [];
textureIdx(allzeros, :) = [];

% Check whether all vertices belong to a triangle. If not, prune the vertices and keep the faces consistent.
utriIdx = unique(tri(:));
remove  = setdiff((1:size(pos, 1))', utriIdx);
if ~isempty(remove)
  [pos, tri] = remove_vertices(pos, tri, remove);
  if texture_per_vert
    % also remove the removed vertices from the texture
    texture(remove, :) = [];
  end
end

if hasimage
      % there is an image with color information

      if texture_per_vert
        % Refines the mesh and textures to increase resolution of the colormapping
        [pos, tri, texture] = refine(pos, tri, 'banks', texture);
        
        picture = imread(image);
        color   = zeros(size(pos, 1), 3);
        for i = 1:size(pos, 1)
          color(i,1:3) = picture(floor((1-texture(i,2))*length(picture)),1+floor(texture(i,1)*length(picture)),1:3);
        end
      else
        % do the texture to color mapping in a different way, without additional refinement
        picture      = flip(imread(image),1);
        [sy, sx, sz] = size(picture);
        picture      = reshape(picture, sy*sx, sz);
        
        % make image 3D if grayscale
        if sz == 1
          picture = repmat(picture, 1, 3);
        end
        [dum, ix]  = unique(tri);
        textureIdx = textureIdx(ix);
        
        % get the indices into the image
        x     = abs(round(texture(:,1)*(sx-1)))+1;
        y     = abs(round(texture(:,2)*(sy-1)))+1;

        % eliminates points out of bounds
        if any(x > sx)
            texture(x > sx,:)   = 1;
            x(x > sx)           = sx;
        end

        if any(find(y > sy))
            texture(y > sy,:)   = 1;
            y(y > sy)           = sy;
        end

        xy    = sub2ind([sy sx], y, x);
        sel   = xy(textureIdx);
        color = double(picture(sel,:))/255;
      end
      
      % If color is specified as 0-255 rather than 0-1 correct by dividing by 255
      if range(color(:)) > 1
        color = color./255;
      end
      
    elseif size(pos, 2)==6
      % the vertices also contain RGB colors
      
      color = pos(:, 4:6);
      pos   = pos(:, 1:3);
      
      % If color is specified as 0-255 rather than 0-1 correct by dividing by 255
      if range(color(:)) > 1
        color = color./255;
      end
      
    else
      % there is no color information
      color = [];
end

pos = pos - repmat(mean(pos,1), [size(pos, 1),1]); % centering vertices
if ~isempty(color)
      color = color;
end

%% Convert to FieldTrip structure

fieldtripHeadSurface = struct( ...
    'pos', pos, ...
    'tri', tri, ...
    'unit', 'mm', ...
    'color', color);
return